## Практическое занятие №3. Процессы в ОС Linux.

### Рассматриваемые вопросы
1. Виртуальные терминалы.
1. Различные редакторы.
1. Работа с процессами.
2. Поиск по man.

### Термины, которые нужно усвоить
1. tty
1. nano, vim, mcedit, gedit
1. bash
1. ctrl+z, ctrl+c
1. jobs, fg, bg
1. ps, ps aux
1. wc
1. init
1. cmd &
1. ctrl+r
2. cat -n
2. tac

### Отчёт по пз
1. **Скриншот**, на котором виден вывод команды **jobs** и три остановленные команды. Третья команда обязательно с редактированием файла с вашей фамилией и номером (формата ivanov-07.txt). Плюсом должна быть отмечана команда номер два  (шаблон "5-07-1 Иванов jobs").
1. **Скриншот**, где видно sleep 100+номер-по-журналу в выводе ps (шаблон "5-07-2 Иванов sleep")
2. **Скриншот**, где виден вывод /etc/hosts в обратном порядке с нумерацией строк (шаблон "5-07-3 Иванов tac"). Строки заданного файла должны идти в обратной порядке, а итоговая нумерация - в прямом.

Скриншоты скопировать в \\\\fs\\prepods\\ваш\_преподаватель\\for\_write\BOS\pz3.

### Ход работы

1. Пройти [опрос ПЗ2](http://gitlabnto:5000/bos/pz2).
1. Запустить виртуальную машину и развернуть ВМ на весь экран (ctrl+alt+enter).

1. Это окно gitlab можно открыть как в хостовой, так и в гостевой ОС.

1. Выбор терминала.
    * Для работы с консолью существуют различные программы, как с графическим интерфейсом, так и без него. После загрузки ОС Linux с помощью сочетания клавиш ctrl+alt+F2 вы можете попасть в виртуальный терминал tty2. При старте ОС Linux запускается 6 терминалов с текстовым интерфейсом (tty2 - tty7, выбирается по нажатию соответственно F2-F7) и один терминал с графическим интерфейсом tty1. По нажатию ctrl+alt+F1 вы вернётесь в привычный вам графический интерфейс. Консольные tty2-tty7 крайне полезны при поломках системы в целом или графической её части.
    * В графическом интерфейсе можно попробовать 3 различных терминала:
        * terminal по умолчанию (в панели слева верхняя кнопка, набрать term, выбрать "Терминал");
        * XTerm (аналогично, выбрать XTerm);
        * terminator (вынесен на панель слева, красная иконка);
    * terminator необходимо устанавливать отдельно. Преимущества:
        * удобная настройка цвета фона и шрифта;
        * поддержка разделения экрана (split screen) - правой кнопкой на терминале, разделить экран. Горячие клавиши ctrl+shift+e разделить вертикально, ctrl+shift+o разделить горизонтально; ctrl+shift+x сделать текущую вкладку во весь экран и обратно (работает после разделения экрана);

1. Терминал (как программа для отображения) запускает командную оболочку unix (или shell, шелл). Стандартом де-факто командной оболочки стал bash - bourne again shell. Существуют, однако, и другие виды - sh, ksh, zsh, csh. Шелл представляет собой интерпретируемый язык программирования (называется также интерпретатором командной строки). Разные шеллы имеют разный синтаксис, поэтому разработанные программы под ksh, например, могут не запуститься под bash.

1. Выбор редактора текста:
    * gedit (обычный блокнот);
    * nano;
    * mcedit (редактор, встроенный в mc - midnight commander, аналог TotalCommander);
    * emacs (не установлен);
    * vim или gvim;

1. Практическая работа в терминале. Терминал, по сути, является однозадачной программой. Существует возможность сделать работу многозадачной, в том числе: 
    * Разделение экрана в terminator;
    * Мультиплексоры экрана tmux или screen;
    * Остановка процессов, запуск фоновых процессов. Этот вариант рассмотрим подробнее.

1. Работа с процессами. Остановка и продолжение работы процессов. Применение достаточно очевидно - представьте, что во время редактирования файла вам понадобилась информация из другого источника (например, нужно вспомнить учётную запись товарища в /etc/passwd). В графическом интерфейсе вы можете открыть другое окно. В терминале без графического интерфейса вы так сделать не можете. На помощь придёт умение останавливать текущий процесс.
    * Открыть терминал (ctrl+alt+t), набрать

    ```bash
    sudo nano /etc/passwd
    ```
    * Снизу написано, как выходить из редактора или делать иные действияю ^ обозначает нажатие ctrl, то есть ctrl+x обозначает выход из редактора. Воспользуемся **ctrl+z**, чтобы остановить выполнение редактора (действует на любые процессы). Получить надпись "[1]+ Остановлено...". Технически, выполняемый процесс получил сигнал SIGSTOP (в следующих ПЗ работу с сигналами рассмотрим подробнее).
    * Выполнить

    ```bash
    ps a
    ```
    * Первый столбец - это PID (process id), второй - это терминал, где запущена команда, третий - статус команды, последний столбец - выполняемая команда;
    * Примеры статусов T - остановленный, R - запущенный, и так далее. Подробнее в мануале, который вызывается командой man
    
    ```bash
    man ps
    ```
    * В мануале нажмите /, введите строку STATE для поиска (нужный раздел называется PROCESS STATE CODES). Поиска далее Ctrl+n, shift+n - поиск в обратном направлении. Выход из мануала по нажатию **q**;
    * В выводе **ps a** найдите PID, соответствующий остановленной команде, и запомните его;
    * Для получения списка остановленных процессов текущего терминала нужно выполнить **jobs**, плюсом отмечено последний активный процесс;
    * Команда **fg** (сокращение от foreground) возвращает последний активный процесс из состояния "остановлен" в состояние "работает", и можно продолжать редактирование. Технически, процесс получает сигнал SIGCONT. Повторный ctrl+z и **ps a** покажет, что PID процесса не изменился от остановки и продолжения. PID процессу задаётся во время его старта и не изменяется в процессе;
    * С остановленным **sudo nano /etc/passwd** введите **sudo nano /etc/shadow**, после чего остановите. Вызов **jobs** покажет два остановленных процесса. **Уясните**, какой из них станет активным после ввода **fg**;
    * Используйте **fg 1** и **fg 2** для восстановления соответственно команды номер 1 и команды номер 2 из списка **jobs**;
    * Откройте новый файл фамилия_номер-по-журналу.txt. Например, 7-ой по журналу тов. Иванов должен выполнить (обратите внимание, что sudo для этого не нужно)

    ```bash
    nano ivanov_7.txt
    ```
    * Остановите процесс редактирования файла с вашей фамилией;
    * **Задание:** создайте ситуацию, при которой виден вывод команды **jobs** и три остановленные команды. Третья команда обязательно с редактированием файла с вашей фамилией и номером. Плюсом должна быть отмечана команда номер два. **Сделайте скриншот**

1. Фоновые процессы. Поиск процессов. 
    * Выполните команду ожидания на 6 секунд

    ```bash
    sleep 6
    ```
    * Обратите внимание, что терминал молча ждёт заданное число секунд, по их окончании он возвращает вам управление и предлагает ввести новую команду. Теперь выполните **sleep 60**. Это пример выполнения некоторой долгой команды. Если вы передумали и хотите прервать выполнение текущей команды, нажмите ctrl+c. На экране появится символ \^C, что является графическим отображением двух символов ctrl и c. Технически, процессу посылается сигнал SIGTERM, который процесс может обработать как угодно. Большинство программ по умолчанию завершают работу при получении этого процесса;
    * Любую команду можно запустить в так называемом фоновом режиме. Выполните **sleep 60**, используйте ctrl+z для остановки процесса. В **jobs** найдите строку "остановлено sleep 60". Выполните **bg** (сокращение от background), и повторно выполните jobs. Теперь этот процесс имеет вид "выполняется sleep 60 &". Знак амперсанда & означает, что процесс выполняется в фоновом режиме;
    * Выполните **sleep 60 &**. Этот процесс запустится в фоновом режиме. В квадратных скобках будет его порядковый номер в jobs, после скобок будет PID запущенного процесса;
    * Подробный список работающих в системе процессов можно получить с помощью **ps aux**. У команды ps множество ключей, которые настраивают формат вывода. Подробнее смотрите в man ps.
    * Вывод ps aux даёт более 200 процессов, которые прямо сейчас обеспечивают работу различных подсистем ОС. Самым первым в списке является процесс /sbin/init, запущенный от пользователя root, с PID 1. Это единственный процесс, не имеющий родительского процесса. Он запускается первым, и является родителем для всех остальных процессов. У каждого процесса (кроме init) есть родитель и может быть множество потомков. Таким образом, процессы организуют **дерево процессов**, довольно сильно похожее на [дерево файловой системы Linux](http://gitlabnto/anetto/wiki/wikis/linux-filesystem);
    * Один из пунктов философии Unix-подобных операционных систем - создавать небольшие программы, решающие одну задачу, и рещающие её хорошо. А ОС обеспечивает простой способ соединения небольших программ в единый тракт обработки. Вспомним из предыдущих ПЗ символ |, который обозначает конвеер команд, объединяющий вывод команды слева от вертикальной черты и ввод команды справа. Посчитаем число строк в нашей таблице процессов. Для этого выполните

    ```bash
    # результат у двух следующих команд одинаковый
    ps aux | wc -l
    ps aux | wc --lines
    ```
    * Пример выше также иллюстрирует существующий стандарт флагов аргументов командной строки. У команды wc (word count) есть короткий флаг -l и длинный флаг --lines, выполняющий одно и то же. Короткий флаг удобен при работе в консоли, длинный - в разрабатываемых скриптах, чтобы через месяц мучительно не вспоминать, зачем же эта опция используется (особенно для редко используемых комманд);
    * К этому моменту фоновый процесс "заснуть на 60 секунд", скорее всего, уже завершился. Запустим такой процесс снова, запомним его PID, и выполним поиск этого процесса среди запущенных командой grep (ищет где угодно что угодно)

    ```bash
    sleep 60 &
    # запоминаем PID. Со знака решётки начинаются комментарии, их bash игнорирует
    ps aux | grep sleep
    ```
    * В выводе последней команды будет два процесса. Один - это искомый процесс sleep 60. **Обратите внимание**, что нет обозначения, что процесс фоновый. Процесс фоновый относительно вашего терминала, то есть его ввод и вывод не связан с терминалом. Второй процесс - это grep --color, который раскрашивает вывод вашей текущей команды, подсвечивая sleep красным;
    * Запустить команду **sleep 60**;
    * Командой kill убить процесс **sleep 60**. Справка по man kill;
    * Запустить повторно команду **sleep 60** и убить процесс командой pkill;

1. Команда ; служит для разделения различных команд на одной строке.

1. **Уяснить** поведение команд вверх, вниз и ctrl+r в терминале.

### Задание для самостоятельной работы

1. Выполнить в терминале (value = 100 + номер по журналу)

    ```bash
    sleep value
    ```
1. Получить строку с запущенным sleep-процессом различными способами:
    * Способ 1. Во время выполнения sleep нажать ctrl+z; найти этот процесс в ps aux; jobs; fg
    * Способ 2. Во время выполнения sleep в одной вкладке (или одном терминале) в другом найти этот процесс в ps aux;
    * Способ 3. Прервать sleep через ctrl+c, запустить sleep value &; найти процесс;
    * **Сделать скриншот**, где видно sleep 100+номер\_по\_журналу в выводе ps aux для одного из способов;
1. С помощью **man cat** выясните, что значит флаг -n команды cat. Кроме того, обратите внимание, что при отсутствии параметра-файла команда cat берёт данные из стандартного потока ввода (standart input). Это значит, что можно использовать cat как очередной элемент в конвеере команд. Выведите содержимое файла /etc/hosts, пронумеровав каждую строку.
2. Для вывода файла в обратном порядке используется команда **tac** (то есть cat в обратном порядке). Воспользовавшись tac и cat, выведите файл /etc/hosts в обратном порядке с нумерацией строк. **Сделайте скриншот**.

### Дополнительные задания на оценку
1. С помощью ctrl+R найти ранее использованную команду "ps aux | wc -l". Искать по подстроке wc, и найти предпоследнее использование.
2. Выполнить cat /var/log/syslog по относительному пути из /home/user/Desktop.