## Практическое занятие №5. Bash-скрипты. Переменные, отладка.

Сегодня поговорим о bash-скриптах — сценариях командной строки, написанных для оболочки bash. Существуют и другие оболочки, например — zsh, tcsh, ksh, но мы сосредоточимся на стандарте де-факто - bash. Напоминаем о важности использования в терминале кнопки tab, сочетания ctrl+r, и кнопок вверх-вниз для навигации по истории команд.

### Рассматриваемые вопросы
* Устройство bash-скриптов и особенности синтаксиса
* объявление и использование переменных, в том числе [встроенных](http://gitlabnto/anetto/wiki/wikis/bash#Встроенные-переменные)
* передача аргументов в bash-скрипт
* отладка

### Термины, которые нужно усвоить
* man bash
* man builtins
* shebang
* which bash
* grep, grep -v
* cut
* read
* особенности '', "", экранирования, обработки переменных с пробелами

### URLы для удобства
[Вот так](http://gitlabnto:5000/ls/bos/pz4) можно посмотреть ещё не принятые скриншоты-отчёты по ПЗ4. Очевидным образом можно получить доступ к ПЗ5 или иным.

Если в конец [таким образом](http://gitlabnto:5000/ls/bos/pz4/3-01) дописать свой номер группы и номер по списку, результатом будет весь список скриншотов по указанному ПЗ и указанного слушателя.

### Долгосрочное домашнее задание

Лежит в [ddz](/ddz.md). На ПЗ5 сдать первое задание из ДДЗ. Результат выполнения задания должен быть загружен в личный репозиторий слушателя: проект timp, каталог bos, файлы решённых заданий task1.sh, и далее по результатам работы скрипта.

### Отчёт по пз
Здесь и далее используется шаблон вида 5-07-ivanov, где 5 - ваша группа, 07 - ваш номер по журналу, Ivanov - ваша фамилия. Шаблон 5-08-petrov - это следующий по списку слушатель с фамилией Петров. Для последнего по списку следующим считается первый по списку.

1. **Скриншот** задания 1, где виден текст вашего скрипта создания файла по шаблону, вывод ls -l по абсолютному пути и по относительному пути (шаблон "5-07-1 Иванов touch").
2. **Скриншот** задания 2, где виден код для получения цифры из файла заданного формата с пробелами в имени (шаблон "5-07-2 Иванов tail and cut")
3. Код выполненной задачи 1 из ДДЗ, загруженный в личный репозиторий timp, каталог bos-ddz.
 
Скриншоты скопировать в \\\\fs\\prepods\\ваш\_преподаватель\\for\_write\BOS\pz5. Посмотреть результат можно [тут](http://gitlabnto:5000/ls/bos/pz4).

### Ход работы

Сценарии командной строки — это наборы тех же самых команд, которые можно вводить с клавиатуры, собранные в файлы и объединённые некоей общей целью. При этом результаты работы команд могут представлять либо самостоятельную ценность, либо служить входными данными для других команд. Сценарии — это мощный способ автоматизации часто выполняемых действий.

1. Летучка по поколениям ОС, заходите http://gitlabnto:5000/bos/pz4.

1. **Как устроены bash-скрипты**
    * В терминале перейти на Рабочий стол. Убедиться, что вы находитесь в каталоге рабочего стола

        ```bash
        # должен вывести /home/user/Desktop
    	pwd
    	```	 
	* Cоздать файл /home/user/Desktop/file.sh - обычно скрипты на bash имеют расширение sh - это договорённость разработчиков между собой. Открыть file.sh в любом удобном вам редакторе и ввести следующий скрипт:
	
        ```bash
    	#!/bin/bash
    	 
    	echo "Going to home"
    	cd ~
    	pwd
    	ls -l
    	```
	* В первой строке - конструкция #!, называется **shebang** (шебанг). После нее #! указываем какую программу необходимо вызвать, чтобы запустить этот скрипт. Чтобы узнать где находится bash, нужно выполнить команду **which bash**. Для интерпретатора скриптов важен shebang в начале файла (а не расширение файла, которое может быть произвольным), при отсутствии shebang bash пробует /bin/bash. 
	* **echo** - выводит на экран строку, переданную в качестве аргумента. В скриптах также можно использовать команды, которые вы используете в терминале.
	* Сохранить файл, сделать его исполняемым и запустить (см. [ПЗ4](http://gitlabnto/anetto/bos/blob/master/pz4.md)])
	* Выполнить в терминале **pwd**, запомнить вывод
	* **Уяснить** почему после выполнения скрипта мы остались в той же директории что и были
	* Выполнить все команды из file.sh в терминале. С помощью pwd убедиться, что текущая директория изменилась.
	
    **Задание 1**: Перейти в директорию **/home/user/Documents**. Создать и запустить в ней скрипт следующего содержания:
    ```bash
    #!/bin/bash  
	cd /home/user/Videos/  
	touch 5-07-ivanov.txt   # как сделать свой шаблон имени - описано в разделе отчет по ПЗ
	cd /var/log/
	# сюда дописать строки ls -l для созданного файла
	# 1) по абсолютному пути (начинается с /) 
	# 2) по относительному пути (начинается с .)
	```	
	Определите, где был создан файл 5-07-ivanov.txt по окончанию работы скрипта. Допишите в скрипт две команды **ls -l "путь к файлу 5-07-ivanov.txt"**	по заданному вами абсолютному пути (начинается с /) и по относительному пути (начинается с .).
	
	Сделайте **скриншот**, где виден текст вашего скрипта создания файла по шаблону, вывод ls -l по абсолютному пути и по относительному пути.
	
	Уяснить **почему** 5-07-ivanov.txt был создан именно там. 

2. **Работа с переменными**. 

	Переменная (variable) - именованная область памяти, то есть у переменной есть имя и она связана с некоторой областью памяти компьютера. В переменную можно записать данные - значения переменной.
	* Имя переменной может содержать: буквы, цифры, _ и не может начинаться с цифры.
	* Значения переменной - числа, строки (кавычки нужны только если в строке есть пробелы), отдельные символы
	* В терминале набрать (в скриптах будет работать также):

		```bash
		# неважно, какой путь будет - файл мы не используем
		path=~/pz # около "=" ставить пробелы нельзя
		path5=ААААААА
		
		# если вы хотите добавить цифру 5 к пути из переменной path
		echo "Path is $path5"
		# обратите внимание на вывод
		echo "Path is ${path}5"
		
		echo '$path'
		echo "\$path"
		
		mkdir new folder
		ls -l
		# почему нет каталога new folder?
		mkdir "new folder $path5"
		ls -l
		mkdir 'very new folder $path5'
		ls -l
		# в чём отличия одинарных и двойных кавычек?
		
		# пример экранирования вместо кавычек
		mkdir supernew\ folder
		```
	* **Уяснить** объявление и **использование** переменных, отличия одинарных и двойных кавычек, экранирование символов.
    * Пример использования переменной. Запустить nano somefile.sh в другом окне или в фоновом процессе. Убедиться, что в выводе **ps aux | grep nano** есть строчка с этим процессом. Получить в переменную pid номер процесса nano, запущенного ранее

    ```bash
    # вырезать из px по пробелам не совсем корректно
    # число 7 в cut может зависить от ряда факторов и подбирается экспериментально
    # правильнее делать с помощью sed или awk, рассмотрим позже
    pid=$(ps aux | grep -v grep | grep nano | cut -d ' ' -f 7)
    
    # убить этот процесс по сохранённому pid
    kill $pid
    ```

    **Задание 3.** Создайте файл "my file with data.txt" с содержимым
    ```
    1; IDDQD
    2; thereisnospoon
    3; hello world
    ```
    С помощью команд tail и cut выделите цифру 3 из созданного файла. **Сделайте скриншот** решения и результата.
    
4. Пользовательский ввод

	read переменная - записать введенное пользователем значение в переменную
	
	Справку по read смотрите в **man builtins**, где есть справка по всем встроенным в bash командам. Чтобы найти информацию про read можно:
	* методом пристального взгляда
	* использовать встроенный поиск (клавиша /) и искать подстроку *read \\[* 
	Напоминаем, что выход из справки по нажатию **q**
		
	Создайте скрипт test.sh и запустите его. После запуска скрипт потребует пользовательский ввод. Введите строку Ivan Ivanov.
	```bash
	#!/bin/bash
	
	# скрипт с ошибкой
	read $name
	mkdir $name
	```
  
5. Отладочная печать в bash-скриптах

	Инструкция **echo** очень полезна при отладке сценариев, она позволяет узнать - действительно ли в заданной переменной хранится то, что вы ожидали получить.
	
	Модифицируем пример из предыдущего пункта и попробуем методом отладочной печати найти потенциальную ошибку. Изменим скрипт таким образом, чтобы понять, какое значение имеет переменная *name* после пользовательского ввода:
		
	```bash
	#!/bin/bash
	
	read $name
	echo $name # отладочная печать
	mkdir $name
	```
	На экран echo выведет пустую строку - можно сделать вывод, что в скрипте неправильно используется команда read. В справке по read можно выяснить, что значок $ ставить не нужно. В итоге, рабочий скрипт будет иметь следующий вид:
	```bash
	#!/bin/bash
	
	read name # убрали знак $
	echo $name
	mkdir $name
	```
	**Обратим внимание**, что повторный запуск скрипта с тем же пользовательским вводом Ivan Ivanov пишет о невозможности создания этих директорий, так как они уже существуют. Корректная обработка такой ситуации состоит в проверке существования директории перед попыткой её создания. Об условных операторах будет рассказано ниже.
	На этом простом примере продемонстрировано, как с помощью команды echo можно отлаживать свои скрипты. 
	Доработаем скрипт так, чтобы он удалял созданные директории. Обратите внимание, что создаётся директория без кавычек, а удаляется директория с кавычками.

	```bash
	#!/bin/bash
	# пример с ошибкой
	read name
	mkdir $name
	rmdir "$name"
	```
	Тем самым будут созданы две директории "Ivan" и "Ivanov", а удаляться будет директория "Ivan Ivanov" - а такой директории нет. Попробуем найти такую ошибку с помощью откладки в bash.
	    	
1. Отладка в bash-скриптах
        	
	Для отладки bash скриптов используется команда *set -x*. Она включает режим, в котором все выполненные команды и их аргументы печатаются в терминале. Таким образом, печать каждой команды, по мере ее выполнения поможет визуализировать поток выполнения скрипта в случае, когда он работает неправильно.
	Для того чтобы отключить этот режим, используется команда *set +x*.  Эта команда необходима, когда вам нужен подробный вывод не по всему скрипту, а только какой-то интересующей вас части скрипта.
	Продемонстрируем отладку на примере:
			
	```bash
	#!/bin/bash
	# пример с ошибкой
	set -x
	read name
	mkdir $name
	rmdir "$name"
	```
	Запустите скрипт, снова введя Ivan Ivanov во время его работы. В терминале вы получите вывод вида
    	
	```bash
	++ read name
	Ivan Ivanov
	++ mkdir Ivan Ivanov
	++ rmdir 'Ivan Ivanov'
	```
	    	
	Из вывода отладки видно, что для mkdir в качестве аргументов поступило два параметра - Ivan и Ivanov, поэтому будет создано 2 директории. В rmdir передан один аргумент - "Ivan Ivanov", интерпретатор попробует удалить такую директорию - но её не существует, поэтому выполнение команды завершиться с ошибкой.
	Самостоятельно **проанализируйте** работу второго примера работы отладки для простейших арифметических вычислений в терминале.
	    
	```bash
	#!/bin/bash
    		
	set -x
	echo `expr 10 + 20 `
    
	set +x
	echo `expr 10 + 20 `
   	```	

1. Выполнить 1 задачи из [ДДЗ](/ddz.md) и **продемонстрировать результат преподавателю**.

    Выполненное задание должно быть загружено в личный репозиторий timp, каталог bos-ddz, там файлы вида task<номер задачи>-<номер задания>.sh. То есть в репозитории вместо использования каталогов дописывать номер каталога в название файла.
    ```bash
    # если по каждой задаче выполнено первое задание
    task1.sh
    task2-1.sh
    task3-1.sh
    task4-1.sh
    task5-1.sh
    ```
### Дополнительные задания на оценку (демонстрировать преподавателю лично)
1. Основной способ решения большинства задач в стиле Unix-way - это длинный конвеер обработки. Разберите следующую длинную команду
    ```bash
    ps aux | grep -v grep | grep nano | cut -d ' ' -f 8 | xargs kill
    ```
2. Создать файл с содержимым
    ```
    БОС;Иванов;7323;5
    БОС;Петров;7323;4
    БОС;Сидоров;7323;5
    ТиМП;Иванов;7323;2
    ТиМП;Петров;7323;3
    ТиМП;Сидоров;7323;3
    ```
    Разработать скрипт, в котором с помощью read и expr вычислить среднюю арифметическую оценку по каждому из предметов.