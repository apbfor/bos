## Практическое занятие №26. Docker

### Термины, которые нужно усвоить
1. docker образ
2. docker контейнер

### Теория
В рамках этого курса вы многократно использовали виртуализацию на базе программного гипервизора. Рассмотрим виртуализацию на уровне операционной системы, то есть контейнерную виртуализацию. Данному типу виртуализации не нужен гипервизор, единственное ядро операционной системы в этом типе виртуализации поддерживает запуск множества изолированных экземпляров пользовательского пространства ядра, которые разделяют ресурсы этого единственного ядра.

Развитие контейнерной виртуализации началось еще в 1979 году с появлением инструмента chroot() в UNIX, целью которого было обеспечение изоляции и предоставление разработчикам отдельную от основной системы площадку для разработки, что позволяет выделить экземпляры пространства имен (namespace). С помощью системного вызова chroot() и соответствующей команды можно изменить корневой каталог. Программе, запущенной с изменённым корневым каталогом, будут доступны только файлы, находящиеся в этом каталоге. В 2000 году в ОС FreeBSD появился механизм Jails, который позволяет разбить операционную систему на несколько независимых, небольших систем – «тюрьмы» - которым можно задавать IP адреса, конфигурации. Создано было это для достижения четкого разделения услуг тех или иных клиентов для небольшого интернет-провайдера. Разработка технологии cgroups, которая обеспечивала контроль за распределение различных ресурсов доступных ОС между группами процессов, была начата в 2006 году сотрудниками Google Полом Менеджем и Рохитом Сетом. Термин «контрольная группа» тогда ещё не использовался, а вместо него употреблялся термин «контейнеры процессов» (processcontainers). Изначальный замысел был в усовершенствовнии механизма cpuset, предназначенного для распределения процессорного времени и памяти между задачами. Но со временем всё переросло в более масштабный проект. В конце 2007 года название processcontainers было заменено на controlgroups. Это было сделано, чтобы избежать разночтений в толковании термина «контейнер» (в то время уже активно развивался проект OpenVZ, и слово «контейнер» стало употребляться в новом, современном значении). В 2008 году механизм cgroups был официально добавлен в ядро Linux (версия 2.6.24). LXC был первой наиболее полной реализацией системы управления Linux контейнерами. Был разработан на базе механизма chroot и cgroups,  которые были включен в официальное ядро Linux, что не требовало создания дополнительных  программных средств для ядра, которые исправляли либо нейтрализовали ошибки в исполняемой программе 

При использовании контейнерной виртуализации между всеми процессами контейнеров разделяется единственное ядро операционной системы, и нет никаких дополнительных накладных расходов на обслуживание ядер гостевых операционных систем. Это также дает возможность запускать на одном физическом сервере много больше полноценных виртуальных окружений похожих на реальные серверы, чем полноценно эмулированных операционных систем, а главное запуск этих окружений происходит намного быстрее, чем эмулированных ОС. Так как при использовании контейнеров пропадает необходимость трансляции системных вызовов гостевых систем, эмуляции работы оборудования и многих других ресурсоёмких операций, существенно возрастает производительность гостевых систем. Как показывают исследования, проведённые компаниями HP, IBM и др., падение производительности для систем контейнерной виртуализации составляет 0.1-1% по сравнению с обычными системами. Когда для виртуальных машин уровень 10-15 % падения производительности считается вполне допустимым. 

Для работы контейнера не требуется полноценного экземпляра операционной системы, а, следовательно, контейнер занимает значительно меньше дискового пространства по сравнению с образом виртуальной машины.

Технология контейнерной виртуализации делает невозможным запуск ОС, отличных от базовой. Уровень изоляции контейнерной виртуализации на текущий момент является высоким, из-за использования таких технологий, как namespace и cgroups, что повышает безопасность гостевых систем.

Docker - программное обеспечение для автоматизации развёртывания и управления программного обеспечения в среде виртуализации на уровне операционной системы. Позволяет «упаковать» программное обеспечение со всем его окружением и зависимостями в контейнер, который может быть перенесён на любой Linux или Windows системе с поддержкой cgroups в ядре, а также предоставляет среду по управлению контейнерами. Механизм DockerEngine отвечает за создание и функционирование контейнеров, предоставляя тем самым эффективный и удобный интерфейс для запуска контейнеров. DockerHub предоставляет около тысячи официальных образов контейнеров с открытым доступом для загрузки, позволяя пользователям быстро начать работу с ними и избежать рутинной работы, ранее уже проделанной другими людьми.

Docker использует клиент-серверную архитектуру для работы, которая обеспечивает высокий уровень производительности и безопасности. Сервер предоставляет определенные услуги клиенту. В архитектуре Docker пара клиент/сервер подобна паре драйвер/ядро, где часть ядра является запущенным в фоновом режиме процессом (Docker демоном), для которого не требуется интерактивная работа и наличие собственного пользовательского интерфейса. Docker демон является посредником в доступе к совместно используемому ресурсу  образу, контейнеру, реестру. Docker клиент принимает все команды и отправляет Docker демону на выполнение с помощью сокетов или RESTful API. 

Образы Docker – это некоторые образцы, используемые для создания Docker контейнеров. Docker образ состоит из некоторой последовательности упорядоченных слоев, доступных только для чтения, каждый из которых описывают какую-то инструкцию, которая записана в Dockerfile. Каждый образ начинается с основного образа такого как ubuntu (основного образа ОС Ubuntu) или fedora (основного образа ОС Fedora). Вы можете также самостоятельно использовать доступные образы в качестве основы для новых, например, вам доступен базовый образ web-сервера Apache, и вы можете использовать его для всех образов ваших web-приложений. Базовый образ определяется при помощи ключевого слова FROM в Dockerfile.

Образ Docker собирается на основе базового образа при помощи простого набора шагов, которые называются инструкциями, которые последовательно записаны в Dockerfile. Каждая инструкция создает новый слой внутри образа. Некоторые примеры инструкций Dockerfile:
* Определить базовый образ (FROM)
* Определить ответственного за поддержку (MAINTAINER)
* Выполнить команду (RUN)
* Добавить файл или директорию (ADD)
* Создать переменную окружения (ENV)
* Какой процесс запустить, когда будет запускаться контейнер из этого образа (CMD)

Docker читает Dockerfile когда вы запускаете сборку (build) образа, выполняет инструкции и возвращает образ.

Docker использует unionfilesystems для объединения своих слоев в единый образ. Union FS позволяет файлам и директориям отдельных файловых систем известным как ветки (branches) быть прозрачно наложенными друг на друга, чтобы образовать единую связную файловую систему.

Эти слои одна из причин, почему в Docker-е так мало накладных расходов на создание нового образа. Когда вы изменяете образ Docker, например, в процессе обновления приложения на новую версию, собирается только новый слой, заменяет только тот слой, который обновляется. Остальные слои остаются нетронутыми. Для распространения обновления все, что вам нужно, это передать обновленный слой. 

Команда «docker create» добавляет слой для записи наверх стека слоев, найденного по идентификатору образа. При этом сама команда не запускает контейнер. Команда «docker start» создает пространство процессов вокруг слоев контейнера. Может быть только одно пространство процессов на один контейнер. 

Собирая свои собственные образы необходимо помнить о том, что каждая инструкция ADD, RUN или COPY в нашем Dockerfile-е будет создавать новый слой поверх предыдущего. Но если мы захотим создать некоторый слой поверх пустого слоя, то мы будем использовать специальный зарезервированный базовый образ Scratch, который имеет нулевой размер. На базе него мы можем запустить статический исполняемый файл. 

Для запуска нашей программы в контейнере мы используем статическое связывание библиотек, указывая флаг «-static» при ее компоновке. При этом размер исполняемой программы становится существенно больше, в отличии от динамической компоновки программы.
Если мы захотим осуществить компиляцию программного кода в самом образе, то образ Scratch нам не подойдет, потому что для этого придется установить соответствующий компилятор, прописав в Dockerfile-e команду «RUN <утилита для установки пакета> install/add <название пакета>». С этой задачей могут справиться образы Alpine и Ubuntu, в которых имеется командный язык оболочки sh. Но в отличии от Alpine Ubuntu наследует sh от bash, - более мощного командного языка.

Контейнер Docker – это запускаемый экземпляр Docker образа. Вы можете запустить, остановить, переместить или удалить контейнер, используя Docker API или консольный клиент. Когда вы запускаете контейнер, вы можете предоставить конфигурационные метаданные такие как сетевая информация или переменные окружения. Каждый контейнер – это изолированная и безопасная платформа для приложений, однако, ему может быть предоставлен доступ к ресурсам, работающим на другом хосте или контейнере.

Контейнеры похожи на директории. В контейнерах содержится все, что нужно для работы приложения. Каждый контейнер создается из образа. Контейнеры могут быть созданы, запущены, остановлены, перенесены или удалены. 

В процессе своей работы контейнер использует Linux ядро хостовой машины, состоит из какого-то количества дополнительных файлов, которые были добавлены к нему в процессе его создания, а также метаданных, связываемых с контейнером в процессе его создания или когда контейнер уже запущен. Каждый контейнер собирается из образа. Образ определяет содержимое контейнера, какой процесс запустить, когда контейнер начинает работать, а также другие всевозможные подробности конфигурации. Образ Docker не изменяем. Когда Docker запускает контейнер из образа, он добавляет дополнительный слой поверх этого образа, который доступен для записи (при помощи UnionFS, как мы видели ранее). Контейнер запускается с помощью команды run, как уже было продемонстрировано ранее. Например, рассмотрим команду: sudo docker run -it ubuntu /bin/bash. 
Клиент запускается с помощью команды docker, с опцией run, которая говорит, что будет запущен новый контейнер. Для запуска контейнера используется образ ubuntu. А когда контейнер будет запущен, выполнится команда /bin/bash. Флаг -it говорит нам о том, что контейнер запущен в интерактивном режиме.
Когда мы запускаем команду, Dockerделает следующие действия:
* скачивает образ ubuntu: Docker проверяет наличие образа ubuntu на локальной машине, и если его нет — то скачивает его с DockerHub. Если же образ есть, то использует его для создания контейнера;
* создает контейнер: когда образ получен, docker использует его для создания контейнера;
* инициализирует файловую систему и монтирует read-only уровень: контейнер создан в файловой системе и read-only уровень добавлен образ;
* инициализирует сеть/мост: создает сетевой интерфейс, который позволяет docker-у общаться с хост-машиной;
* Установка IP адреса: находит и задает адрес;
* Запускает указанный процесс: запускает приложение.

Обрабатывает и выдает вывод вашего приложения: подключается и логирует стандартный вход, вывод и поток ошибок вашего приложения, что бы вы могли отслеживать как работает ваше приложение.


### Запуск исполняемого файла в Docker на базе scratch образа
1. Вся работа с docker ведётся из-под суперпользователя. Использовать sudo или действовать от рута - личный выбор каждого. Стоит помнить, что от рута легко "сделать что-то не то", выполнив rm -rf или подобное. **Работа от имени пользователя root является плохом тоном, особенно в сфере "Информационная безопасность"**.
1. Создайте в домашнем директории директорию project. Создайте там файл hello.c с содержимым

    ```C
    #include <stdio.h>
    
    int main(int argc, char ** argv) {
        if(argc == 1) {
        printf("Enter the string!\n");  
    }
        else {
        printf("Hello, %s\n", argv[1]);
    }
        return 0;
    }
    ```
1. Скомпилируйте этот код в исполняемый файл hello\_not\_static. Готовый исполняемый файл будет весить около 8 килобайт.

    ```bash
    gcc -o hello_not_static hello.c
    ```
1. Проверьте работоспособность созданного файла (123 - это аргумент командной строки)

    ```bash
    ./hello_not_static 123
    ```
1. Создайте Dockerfile (файл должен иметь строго такое название) с содержимым

    ```Dockerfile
    FROM scratch
    COPY hello_not_static /hello
    ENTRYPOINT ["./hello"]
    ```
2. Постройте docker-образ для созданного исполняемого файла и проверьте его в библиотеке доступных образов

    ```bash
    # обратите внимание, как происходить пошаговое построение образа
    docker build -t hello .
    
    # найдите образ hello, созданный только что
    docker images
    ```
1. Запустите контейнер и посмотрите его в списке созданных контейнеров

    ```bash
    # результат - ошибка standard_init_linux.go:195: exec user process caused "no such file or directory"
    docker run hello 123
    
    # есть контейнер, созданный из image hello с командой ./hello 123
    docker ps -a
    ```
1. Причина неработоспособности запуска выше состоит в том, что созданный hello\_not\_static содержит динамические библиотеки, которых нет внутри изолированного окружения контейнера.

    ```bash
    # посмотреть список используемых динамических библиотек
    ldd hello_not_static
    ```
1. Скомпилируем наш код статически. В man gcc можно найти флаг -static со следующим описанием: "On systems that support dynamic linking, this prevents linking with the shared libraries." Результирующий исполняемый файл теперь занимает почти 900 килобайт вместо 8.

    ```bash
    gcc -o hello -static hello.c
    # убедимся, что наш результат - не динамический исполняемый файл
    ldd hello
    ```
1. Исправьте Dockerfile так, чтобы внутрь образа копировался файл hello, перестройте образ и запустите контейнер. Проверьте в images и ps наличие нового образа и отработавшего контейнера.
2. Исправьте Dockerfile так, чтобы скомпилировать hello.c внутри контейнера. Из-за чего процесс компиляции завершить не получится?

### Использование образа ubuntu
1. Как вы убедились на предыдущем пункте, в scratch образе нет ничего - ни библиотек, ни компилятора, ни интерпретатора, ни командной оболочки. Трудоёмко в каждый создаваемый образ добавлять то подмножество программного обеспечение, которое нужно под конкретный проект. Решение этой проблемы состоит в использовании некоторых готовых образов, например, образа ubuntu. Этот образ включает в себя весь тот набор окружения, что имеет операционная система ubuntu. В результате имеется базовый образ ubuntu примерно в 100 мегабайт с полным джентельменским набором. Есть минималистичные образы - например, alpine занимает всего 5 мегабайт, предоставляя полноценный bash, gcc и прочие нужные вещи. В alpine присутствует собственный менеджер пакетов, что позволяет легко дополнять образ необходимым программным обеспечением.
2. Скачайте из \\\\fs\\Кафедры\\732\\БОС\\ubuntu.tar - Docker-образ Ubuntu и загрузите в файловую систему виртуальной машины.
2. С помощью docker load -i <имя образа> загрузите ubuntu.tar в локальный репозиторий образов.
3. Запустите контейнер в интерактивном режиме (docker run -it ubuntu). Изучите файловую систему внутри контейнера. Контейнер - это некоторая песочница, в которой можно сломать что угодно без последствий. Можно попробовать популярные в интернете способы подшутить над новичками. Например, запретим исполнение у программы chmod - откатить это действие непросто. **Выполнять строго внутри контейнера**.

```bash
chmod -x /bin/chmod
chmod  # как вернуть обратно?
```
1. Завершите контейнер с помощью ctrl+d или exit. С помощью docker ps убедитесь, что запущенных контейнеров нет, а в выводе docker ps -a найдите завершенный только что контейнер. Поместите container id в буфер обмена.
2. С помощью docker start <container\_id> снова запустите этот контейнер. Найдите его в docker ps. Войдите в контейнер с помощь docker attack <container\_id>. Это вместе можно сделать с помощью docker start -a <container\_id>.
3. В Dockerfile произведите установку пакета mywc, разработанного в рамках предыдущего практического занятия.