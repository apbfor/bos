## Практическое занятие № 7. Виртуальная файловая система proc

### Рассматриваемые вопросы
1. Виртуальная файловая система procfs
2. Переменные окружения

### Термины, которые нужно усвоить
1. procfs
2. PID, PPID
3. файловый дескриптор
4. < > >> 2> 2>> &> &>>
5. PATH
6. HOME
7. tr

### Отчёт по пз
1. **Скриншот** задания 1, где видно переопределение stdin, stdout, stderr на заданные файлы ("5-07-1 Иванов stdin").
1. **Скриншот** задания 2, где видны заданные по заданию cwd и cmdline запущенного процесса ("5-07-2 Иванов cwd").
1. **Скриншот** задания 3, где видны перенаправленные потоки для конвеера ("5-07-3 Иванов pipe-fd").
1. **Скриншот** задания 4, где видно type cmd, вызов cmd и результаты работы. Вместо cmd команда по варианту "5-07-4 Иванов path".

### Ход работы

1. Пройти [опрос ПЗ6](http://gitlabnto:5000/bos/pz6).
 
1. **procfs** — виртуальная файловая система. Обычно её монтируют на /proc. В /proc файлы нулевой длины не являются ни бинарными, ни текстовыми, но их содержимое можно просмотреть. Эта специальная директория хранит все детали о вашей системе Linux, включая её ядро, процессы и параметры конфигурации. 

    В Linux все представлено в виде файла. Доступ к устройствам (расположены в /dev) происходит также, как и к файлам. Директория /proc содержит виртуальные файлы. Их можно вывести списком, но они не существуют на диске; операционная система создает их «на лету», если вы делаете попытку их прочитать. В **man proc** подробно описано содержимое procfs.

1. Создайте скрипт ppid.sh с содержимым
    
    ```bash
    #!/bin/bash
    echo my PID is $$
    echo my parent PID is $PPID
    ```
    Сделайте скрипт исполняемым и запустите его несколько раз. **Запускать нужно созданный скрипт**, а не выполнять команды в консоли. Обратите внимание, что PID процесса при каждом запуске новый, а родительский PID (parent PID, PPID) один и тот же - это PID терминала, из которого вы запускаете скрипт.
    
1. Запомните PPID, далее **подставляйте вместо него своё число**.

    ```bash
    ls /proc
    ```
    На экране множество чисел и некоторые строки. Каждое число соответствует некоторому процессу в операционной системе. Во втором столбце команды **ps aux** вы можете видеть те же номера процессов. Найдем процесс нашего терминала (это PPID из вывода скрипта выше; его же можно получить с помощью **echo $$**)

    ```bash
    # вместо PID должно быть ваше число из скрипта
    # fd == file descriptor
    ls -l /proc/PPID/fd
    ```
    На экране будут строки соответствия открытых дескрипторов для процесса и некоторых файлов.
    
    0 - это дескриптор стандартного потока ввода (stdin, откуда процесс берёт данные), отображается в /dev/pts/2
    
    1 - дескриптор стандартного потока вывода (stdout, куда данные выводятся)
    
    2 - дескриптор стандартного потока ошибок (stderr, куда выводятся ошибки)
    
    255 - служебный дескриптор, используемый в bash
    
    /dev/pts - это устройства, соответствующие виртуальному терминалу - так называемые Pseudo-TerminalS. То есть по умолчанию данные вводятся с клавиатуры терминала и выводятся на экран терминала. Легко проверить, что /dev/pts/2 соответствует нашему терминалу. Выполните
    
    ```bash
    # отправляем 1 в файл /dev/pts/2
    echo 1 > /dev/pts/2
    # результат сразу отобразится на экране - введенная в echo строка
    ```
   **Важно запомнить**, что дескрипторы 0, 1 и 2 создаются всегда при порождении процесса. Но можно в любой момент (в том числе при старте процесса) изменить тот файл, на который эти дескрипторы ссылаются.
1. Для процесса можно узнать, какой командой он был запущен
   
    ```bash
    cat /proc/PPID/cmdline; echo
    ```
    В cmdline хранится команда (со всеми аргументами командной строки). В конце дописано echo, что добавит перенос строки - в cmdline переноса строки нет, и вывод терминала "налезет" на выведенное содержимое.
    
1. Доработайте скрипт ppid.sh, чтобы он содержал следующий код
    ```bash
    #!/bin/bash
    echo my PID is $$
    echo my parent PID is $PPID
    
    echo something >> 1.txt
    
    while read line
    do
        sleep 180
    done < 1.txt
    ```
    Запустите скрипт. **Пока запущен процесс ppid.sh**, работайте в другом окне терминала или другой вкладке. При завершении процесса ppid.sh перезапускайте его.
    
    Теперь смотрим не в родительский процесс, а в **процесс нашего скрипта**. С помощью **ls -l /proc/PID/fd** посмотрите на имеющиеся дескрипторы. Обратите внимание, что stdin теперь берётся из файла 1.txt, а не с клавиатуры. Таким образом действует < после done - переопределяет stdin файла, в результате чего read считывает информацию из этого файла. Сама команда read об этом ничего не знает, она просто умеет читать данные из 0 дескриптора.
    
    **Осознайте**, что вы только что делали.

1. Создайте файл pid-and-write.c с содержимым
    ```c
    /*
     * Prints it pid, ppid
     * Opens file
     */
    #include <stdio.h>
    #include <unistd.h> // write
    #include <fcntl.h> // for O_CREAT, O_RDWR, O_WRONLY, O_RDONLY, O_APPEND
    #include <string.h> // sprintf
    
    #define BUF_SIZE 256
    
    int main()
    {
        int fd;
        char msg[BUF_SIZE] = "";
    
        printf("my PID: %d , parent PID: %d \n", getpid(), getppid());
    
        fd = open("some_file.txt", O_CREAT | O_APPEND | O_RDWR, 0644);
        printf("Opened a file, fd = %d \n", fd);
        printf("You've got 120 sec to check /proc/%d/fdinfo/3\n", getpid());
        sleep(120);
    
        sprintf(msg, "0123456789");
        write(fd, msg, strlen(msg));
        printf("Writed smth to file, look at new file position \n");
        printf("Sleeping...");
        sleep(120);
        return 0;
    }
    ```
    Представленная программа печатает свой и родительский PID-ы. После чего открывает файл, печатает номер открытого файлового дескриптора и засыпает на 2 минуты. Через 2 минуты программа пишет в файл некоторую строку, в результате чего указатель на текущую позицию в файле (или каретка) смещается.
    
    Не путайте файловый дескриптор (относится процессу, открывшему файл) и индексный дескриптор (относится к файловой системе).
    
    Скомпилируйте этот файл и выполните его

    ```bash
    gcc pid-and-write.c -o pid-and-write
    # чтобы посмотреть на cmdline с аргументами командной строки, добавим их при вызове программы. Эти аргументы ни на что не влияют
    ./pid-and-write some command args
    ```
    **Пока запущен процесс pid-and-write some**, в другом окне или вкладке выполните

    ```bash
    # -A позволяет отобразить непечатаемые символы, которыми разделены аргументы в cmdline
    # вместо пробелов между аргументами будет знак ^@
    # в конце echo для переноса строки - в cmdline в конце нет \n
    cat -A /proc/PID/cmdline ; echo
    
    # команда tr умеет менять один символ на другой, заменим 
    # заменим с помощью tr непечатаемый символ на пробел
    cat -A /proc/PID/cmdline | tr ^@ ' ' ; echo
    
    # дескрипторы 0,1,2 также указывают на /dev/pts/2 - наш терминал
    # 3 файловый дескриптор является символической ссылкой на открытый в программе файл
    ls -l /proc/PID/fd
    
    # команду ниже нужно выполнить дважды - до записи программы в файл и после неё
    cat /proc/PID/fdinfo/3
    ```
    Строка pos содержит текущее смещение указателя внутри файла (так называемой каретки). Кто помнит seek при работе с файлами - эта функция изменяет pos. Строка flags отвечает за вид доступа к файлу (например, только для чтения) и ряд параметров. Строка mount_id - это порядковый номер, по которому в /proc/PID/mountinfo можно посмотреть, как смонтировано соответствующее файлу устройство.
    
    Обратите внимание, что после записи в файл указатель pos с нуля сдвинулся на некоторое число. Флаги файла при этом не изменились.

1. Теперь переопределим stdin и stderr процесса. Возьмём stdin из первого скрипта ppid.sh (наша программа stdin не читает, так что не важно), а ошибки отправим в новый файл err.txt. При этом stdout мы не изменяем, поэтому процесс будет писать на экран.

    ```bash
    ./pid-and-write < ppid.sh 2> err.txt
    
    # в другой вкладке/терминале
    ls -l /proc/PID/fd
    # 0 и 2 дескрипторы теперь ссылаются на наши файлы
    ```
    Таким образом, вызовы read в коде будут считывать информацию из файла ppid.sh. Все ошибки будут писаться в err.txt. Аналогично можно переопределить stdout, тогда весь вывод нашего скрипта будет сложен в указанный файл. Удобно при запуске программ, у которых большой вывод, который нужно сохранить.
    
    Итого:
    * < переопределяет стандартный поток ввода
    * > стандартный поток вывода (если файл существует, то содержимое будет удалено)
    * >> стандартный поток вывода (если файл существует, то новый вывод допишется в конец)
    * 2> стандартный поток вывода ошибок (по аналогии с >)
    * 2>> по аналогии с >>
    * &> вывод и ошибки (не допускается пробел после &, иначе амперсанд интерпретируется как "запустить в фоновом режиме")
    * &>> по аналогии с >> и 2>>

    **Задание 1**. Переопределить stdin на файл с номером группы, stdout на файл с вашим номером по списку, а stderr на файл с вашей фамилией. Сделать скриншот, где видно в fd указанные файлы. **Подсказка:** для поиска PID запущенного вами процесса воспользуйтесь командой **grep**.

1. Продолжим рассматривать возможности proc. Продолжаем запускать **pid-and-write** и работать с полученным дескриптором PID. Для удобства можно увеличить sleep в скрипте. Не забудьте перекомпилировать программу.

    ```bash
    # ссылка на current working directory процесса
    # если внутри процесса будет cd куда-то, то эта ссылка также изменится
    ls -l /proc/PID/cwd
    
    # ссылка на исполняемый файл процесса
    ls -l /proc/PID/exe
    
    # статистика по операциям ввода-вывода для процесса, подробнее в man proc
    cat /proc/PID/io

    # ограничения процесса по различным параметрам, вроде CPU и оперативной памяти
    cat /proc/PID/limits
    
    # диапазоны адресов памяти процесса, которые отображены на диск. Например, библиотеки с расширением .so
    cat /proc/PID/maps
    
    # для каждого потока в процессе заводится свой каталог, внутри - то же, что и в /proc/PID процесса
    ls -l /proc/PID/task
    ```

    **Задание 2:** Запустить процесс таким образом, чтобы его рабочей директорией был каталог /home/user/Ivanov, где вместо Ivanov должна быть ваша фамилия. При этом в аргументах командной строки должно быть три параметра - номер группы, номер по журналу, фамилия. **Сделать скриншот**, где видны cwd и cmdline запущенного процесса.

1. Вернёмся к ppid.sh. Запустите ./ppid.sh | tail -f. С помощью изученных способов выясните:
    * куда указывают стандартные потоки ppid.sh
    * куда указывают стандартные потоки tail
    
    **Задание 3**. Сделайте скриншот, из которого понятны указанные перенаправления.

    
1. В proc есть данные не только по процессам, но и по системе в целом. Рассмотрим только один пример.

    ```bash
    # данные об использовании оперативной памяти
    cat /rpco/meminfo
    ```

1. Переменная среды (англ. **environment variable**) — текстовая переменная операционной системы, хранящая какую-либо информацию.

    В Windows все переменные окружения хранятся в реестре. Вывод переменных в консоли по echo %VAR%

    В UNIX переменные окружения берутся из /etc/profile и ~/.bash_profile, затем наследуется порождёнными процессами. При создании дочерний процесс получает локальную копию среды родительского процесса, а, значит, не может изменить напрямую глобальные установки. Вывод echo $VAR.
    
    Для нашего **pid-and-write** посмотрим доступные переменные окружения.

    ```bash
    # все переменные окружения для процесса
    # там опять вместо пробелов непечатаемый символы
    # заменим с помощью tr непечатаемый символ на перенос строки
    # less для удобства чтения
    cat -A /proc/PID/environ | tr ^@ \\n | less
    # того же можно добиться, использов
    strings /proc/PID/environ
    ```
    Обратим внимание на ряд переменных окружения. В первую очередь заметим, что все переменные окружения названы в верхнем регистре. В SHELL хранится путь к текущей командной оболочке, это известный нам /bin/bash. В USER хранится текущий пользователь. В LANG - локаль пользователя. В HOME - домашний каталог пользователя. 
    
    В OLDPWD хранится предыдущий каталог. То есть если в программе сделать cd /home/an/1, потом cd /home/an/2, то /home/an/1 будет в OLDPWD. С помощью **cd -** можно вернутся в этот предыдущий каталог. Обратите внимание - не родительский, ведь перейти можно по абсолютному пути куда угодно.
    
    PATH содержит список каталогов, в которых осуществляется поиск программ для запуска. То есть, если пользователь вводит **ls**, то командная оболочка проверяет наличие такой программы в /usr/local/sbin, потом в /usr/local/bin и так далее. В каком каталоге первый раз ls встретится, та программа и выполнится. Изменив PATH (а это обычная переменная, как и остальные переменные окружения), можно повлиять на запуск программ. Например, можно указать в начале PATH путь /home/an/my-folder-with-virus/ и создать в этом каталоге программу ls. В этом случае будет вызываться ваш ls, а не системный.

1. Подмена PATH.

    **Задание 4:** подменить PATH таким образом, чтобы выполнение заданной команды по варианту вызывало разработанную вами программу, а не системную. **Сделать скриншот**, где виден вывод **type cmd** (вместо cmd - заданная команда), вызов cmd и результат её работы. Результатом работы программы должна быть строка по шаблону 5-7-Ivanov. Варианты заданий (брать задание как в ДДЗ, номер в журнале по модулю всего в группе плюс один):
    * ls
    * cat
    * man
    * mount
    * less
    * nano
    * bash
    * mv
    * cp

1. С помощью **tr** замените всё гласные буквы своей фамилии на заглавную A. Язык (русский или английский) значения не имеет.    

### Дополнительные задания на оценку (демонстрировать преподавателю лично)
1. Подменить PATH таким образом, чтобы была подменены команды type и which. Как и в задании 3, результатом работы подменённых type и which должна быть строка по шаблону 5-7-Ivanov. При демонстрации результата в терминале должно быть видно, что при вызове which на экран пишется заданная строка, а type подменить таким образом не удаётся - так как это встроенная команда bash. При этом с помощью type и which нужно показать местоположение подменённых type и which.

1. Продемонстрировать вызов исходных type и which при наличии подменённых в PATH.
